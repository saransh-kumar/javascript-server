<<<<<<< Updated upstream
**12Factor app** 

***Twelve Factor App*** : It helps to create a *declarative* way of coding so that its easy to understand and easy to manipulate in no time. Saving more time will make product cost effective and make space of free time for another task. It provides portability between execution and environment and make clear cut contract. Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;Minimize divergence between development and production, enabling continuous deployment for maximum agility;And can scale up without significant changes to tooling, architecture, or development practices.
=======
**12actor app** 

***Twelve Facotor App*** : It helps to create a *declarative* way of coding so that its easy to understand and easy to manipulate in no time. Saving more time will make product cost effective and make space of free time for another task. It provides portability between execution and environment and make clear cut contract. Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;Minimize divergence between development and production, enabling continuous deployment for maximum agility;And can scale up without significant changes to tooling, architecture, or development practices.
>>>>>>> Stashed changes


1. **Codebase** - We can *track our code in versions* so that if someone want to see any previous code can check the version. One codebase tracked in revision control, many deploys and can easily work on it. There is only one codebase per app, but there will be many deploys of the app. A deploy is a running instance of the app. This is typically a production site, and one or more staging sites. Additionally, every developer has a copy of the app running in their local development environment, each of which also qualifies as a deploy.The codebase is the same across all deploys, although different versions may be active in each deploy. For example, a developer has some commits not yet deployed to staging; staging has some commits not yet deployed to production. But they all share the same codebase, thus making them identifiable as   different deploys of the same app.

2. **Dependencies** - Explicitly declare and isolate dependencies.Most programming languages offer a packaging system for distributing support libraries, such as CPAN for Perl or Rubygerms for Ruby. Libraries installed through a packaging system can be installed system-wide (known as “site packages”) or scoped into the directory containing the app (known as “vendoring” or “bundling”).A twelve-factor app never relies on implicit existence of system-wide packages. It declares all dependencies, completely and exactly, via a dependency declaration manifest. Furthermore, it uses a dependency isolation tool during execution to ensure that no implicit dependencies “leak in” from the surrounding system. The full and explicit dependency specification is applied uniformly to both production and development.

3. **Config** - Store config in the environment.The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard.

4. **Backing services** - Backing services like the database are traditionally managed by the same systems administrators who deploy the app’s runtime. In addition to these locally-managed services, the app may also have services provided and managed by third parties. Examples include SMTP services (such as Postmark), metrics-gathering services (such as New Relic or Loggly), binary asset services (such as Amazon S3), and even API-accessible consumer services (such as Twitter, Google Maps). Treat backing services as attached resources

5. **Build, release, run** - Strictly separate build and run stages. Deployment tools typically offer release management tools, most notably the ability to roll back to a previous release. For example, the Capistrano deployment tool stores releases in a subdirectory named releases, where the current release is a symlink to the current release directory. Its rollback command makes it easy to quickly roll back to a previous release.

6. **Processes** - Execute the app as one or more stateless processes. The memory space or filesystem of the process can be used as a brief, single-transaction cache. For example, downloading a large file, operating on it, and storing the results of the operation in the database. The twelve-factor app never assumes that anything cached in memory or on disk will be available on a future request or job – with many processes of each type running, chances are high that a future request will be served by a different process. Even when running only one process, a restart (triggered by code deploy, config change, or the execution environment relocating the process to a different physical location) will usually wipe out all local (e.g., memory and filesystem) state.

7. **Port Binding** - The twelve-factor app is completely self-contained and does not rely on runtime injection of a webserver into the execution environment to create a web-facing service. The web app exports HTTP as a service by binding to a port, and listening to requests coming in on that port. Export services via port binding.

8. **Concurrency** - Any computer program, once run, is represented by one or more processes. Web apps have taken a variety of process-execution forms. For example, PHP processes run as child processes of Apache, started on demand as needed by request volume. Java processes take the opposite approach, with the JVM providing one massive uberprocess that reserves a large block of system resources (CPU and memory) on startup, with concurrency managed internally via threads. In both cases, the running process(es) are only minimally visible to the developers of the app.Scale out via the process model.

9. **Disposability** - Processes should strive to minimize startup time. Ideally, a process takes a few seconds from the time the launch command is executed until the process is up and ready to receive requests or jobs. Short startup time provides more agility for the release process and scaling up; and it aids robustness, because the process manager can more easily move processes to new physical machines when warranted.Maximize robustness with fast startup and graceful shutdown.

10. **Dev/prod parity** - Keep development, staging, and production as similar as possible. The twelve-factor developer resists the urge to use different backing services between development and production, even when adapters theoretically abstract away any differences in backing services. Differences between backing services mean that tiny incompatibilities crop up, causing code that worked and passed tests in development or staging to fail in production. These types of errors create friction that disincentivizes continuous deployment. The cost of this friction and the subsequent dampening of continuous deployment is extremely high when considered in aggregate over the lifetime of an application.

11. **Logs** - Treat logs as event streams.Lightweight local services are less compelling than they once were. Modern backing services such as Memcached, PostgreSQL, and RabbitMQ are not difficult to install and run thanks to modern packaging systems, such as Homebrew and apt-get. Alternatively, declarative provisioning tools such as Chef and Puppet combined with light-weight virtual environments such as Docker and Vagrant allow developers to run local environments which closely approximate production environments. The cost of installing and using these systems is low compared to the benefit of dev/prod parity and continuous deployment.

12. **Admin processes** - One-off admin processes should be run in an identical environment as the regular long-running processes of the app. They run against a release, using the same codebase and config as any process run against that release. Admin code must ship with application code to avoid synchronization issues. Run admin/management tasks as one-off processes


<<<<<<< Updated upstream
***Knowing atleast 8 can make you a good developer. It is important to learn these to make a good and secure applications or a product.***
=======
***Knowing atleast 8 can make you a good developer. It is important to learn these to make a good and secure applications or a product.***
>>>>>>> Stashed changes
